---
layout: post
author: SiYu Liu
categories: Python
title: 《利用python进行数据分析》第四章NumPy笔记 
tags: Python
---

* content
{:toc}

Numpy的一些函数和特性简记






## 参数
xx.ndim 数组长度
xx.shape 维度大小
xx.dtype 数据类型

## 创建函数

|函数|说明|
|:--|:--|
|array(xx)|将输入数据xx（列表，元祖，数组或其他序列类型）转换为ndarray。要么推断出dtype，要么显式指定dtype。默认直接复制输入数据|
|asarray|将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制|
|arange|返回一个有序的ndarray|
|ones，ones_like|根据指定的形状和dtype创建一个全1数组，ones_like以另一个数组为参数，并根据其形状和dtype创建一个全1数组|
|zeros，zeros_like|全0数组|
|empty，empty_like|创建新数组，只分配内存空间但不填充任何值|
|eye，identity|创建一个正方形N×N单位矩阵（对角线为1，其余为0）|

## 数据类型

|类型|类型代码|类型|类型代码|
|:--|:--|:--|:--|
|int8, uint8|i1, u1|int16, uint16| i2, u2|
|int32, uint32|i4, u4|int64, uint 64|i4, u4|
|float16|f2|float32|f4 or f|
|float64|f8 or d|float128|f16 or g|
|complex64, complex128|c8, c16(复数)|complex256|c32|
|bool|?|object(python对象)|O|
|string_|S|unicode_|U|

#### 数据类型的转换
xx.astype(dtype)

## 数组与标量之间的计算

* vectorization(矢量化)
即大小相等的数组之间的任何算术运算都会将运算应用到元素级
* broadcaSsting（不同大小的数组之间的运算)
具体见12章

## 基本的索引和切片

数组切片跟列表切片最重要的区别在于，数组切片是原是数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上：
```python
In[57]: arr_slice = arr[5:8]
In[58]: arr_slice[1] = 12345
In[59]: arr
Out[59]: array([0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
In[60]: arr_slice[:] = 64
In[61]: arr
Out[61]: array([0, 1, 2, 3, 4, 64, 64, 64, 8, 9])
```
可以看到，对视图arr_slice的操作反映到了源数组arr上

** 如果要复制切片数组，则需要arr_slice.copy() **

#### 数组元素索引

```python
In [2]: arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

In [3]: arr[0][2]
Out[3]: 3

In [4]: arr[0, 2]
Out[4]: 3
#

```

#### 高纬度数组切片

```python
In [5]: arr = np.array([[0, 1, 2],[4, 5, 6], [7, 8, 9]])

In [6]: arr[:2]
Out[6]: 
array([[0, 1, 2],
       [4, 5, 6]])

In [7]: arr[:2, 1:]
Out[7]: 
array([[1, 2],
       [5, 6]])
#即索引和切片可以一起去使用，返回的同样是视图
```

#### 布尔型索引

```python
In [24]: data[(names == 'bob') | (names == 'bin')]
Out[24]: 
array([[-1.51820833,  0.93871624, -0.82567594, -0.84420024],
       [ 1.32281996,  2.35355066, -0.82956821, -0.23053934]])

In [25]: data = numpy.random.randn(6, 4)

In [26]: names
Out[26]: 
array(['bob', 'jashon', 'richard', 'bin', 'google', 'chill'], 
      dtype='<U7')

In [27]: data[(names == 'bob') | (names == 'bin')]
Out[27]: 
array([[ 0.74605977,  0.35704256,  0.27657912, -0.87375882],
       [ 0.03110279,  0.06189641, -0.07518686, -0.42962777]])

In [28]: data[- ((names == 'bob') | (names == 'bin'))]

Out[28]: 
array([[-0.81259874, -1.63085304,  1.20093301, -0.01940712],
       [ 0.34489263, -1.70169785,  0.10215123, -0.0672559 ],
       [ 1.89754785, -0.19561268,  0.64153751, -0.50974257],
       [-0.10947979,  0.0805697 ,  0.96664486, -1.08070463]])

In [29]: mask = (names == 'bob') | (names == 'bin')

In [30]: mask
Out[30]: array([ True, False, False,  True, False, False], dtype=bool)

```

#### 通过布尔型数组设置值

例：将data中的所有复制设置为0

```python
In [31]: data[data < 0] = 0

In [32]: data
Out[32]: 
array([[ 0.74605977,  0.35704256,  0.27657912,  0.        ],
       [ 0.        ,  0.        ,  1.20093301,  0.        ],
       [ 0.34489263,  0.        ,  0.10215123,  0.        ],
       [ 0.03110279,  0.06189641,  0.        ,  0.        ],
       [ 1.89754785,  0.        ,  0.64153751,  0.        ],
       [ 0.        ,  0.0805697 ,  0.96664486,  0.        ]])
```

#### 花式索引

* 传入一个用于指定顺序的整数列表或ndarray，以特定顺序选取行子集

```python
In [36]: arr
Out[36]: 
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])

In [37]: arr[[4, 3, 0, 6]]   #整数为正序查找
Out[37]: 
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])

In [38]: arr[[-3, -5, -7]]   #负数为倒序查找
Out[38]: 
array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 1.,  1.,  1.,  1.]])
```

** 注意：一次传入多个索引数组会返回一个一位数组，而非矩阵区域　**

```python
In [41]: arr
Out[41]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

In [42]: arr[[1, 5, 7, 2], [0, 3, 1, 2]]
Out[42]: array([ 4, 23, 29, 10])
#这里返回的是(1,0),(5,3),(7,1),(2,2)元素
In [43]: arr[[1, 5, 7, 2]][ : ,[0, 3, 1 ,2]]
Out[43]: 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
#这里是先通过传入一个索引数组返回矩阵，再通过切片创建矩阵，最红再一次通过花式索引来返回特定元素
```

要返回一个矩阵区域，另一种方法是用np.ix_函数

```python
In [44]: arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
Out[44]: 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
```

** 记住！！！： ** == ** 花式索引跟切片不一样，它总是将数据复制到新数组中 ** ==

#### 数组转置和轴对换

通过矩阵的T属性，可以返回源数组的转置矩阵 ** 视图 **

```python
In [47]: arr 
Out[47]: 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [48]: arr.T
Out[48]: 
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
```

复杂矩阵通过transpose或swapaxes函数

## 通用函数：快速的元素级数组函数

可将通用函数（ufunc）看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器

#### 一元ufunc

|函数|说明|
|:--|:--|
|abs,fabs|整数，浮点数或负数绝对值，对于非复数值，可用更快的fabs|
|sqrt|平方根|
|square|平方
|exp|指数e^x|
|log，log10，log2，log1p||
|sign|计算正负号：1（正），0（零），-1（负）|
|ceil|大于等于该值的最小整数（ceiling值）|
|floor|小于等于该值的最大整数|
|rint|四舍五入到最接近的整数|
|modf|将数组的小数和整数部分一两个独立数组形式返回|
|isnan|返回一个表示“哪些值是NaN（这不是一个数字）”的布尔型数组|
|isfinite，isinf|返回一个表示“哪些元素是有穷的”，“无穷的”的布尔型数组|
|cos，cosh，sin，sinh，tan，tanh|普通型和双曲型三角函数|
|across，acrossh，arcsin，arcsinh，arctan，arctanh|反三角函数|
|logical_not|计算各元素not x的真值，相当于-arr|

#### 二元func

|函数|说明|
|:--|:--|
|add|加法|
|subtract|第一个数组减去第二个数组|
|multiply|乘法|
|divide，floor_divide|除法，丢弃余数出发|
|power|第一个A数组，第二个B数组，计算A^B|
|maximum，fmax|最大值，fmax将忽略NaN|
|minimum，fmin|最小值|
|mod|取模|
|copysign|将第二个数组中值得符号复制给第一个数组|
|greater，greate_equal,less,less_equal,equal, not_equal|>, >=, <, <=, ==, !=,返回布尔数组|
logical_and, logical_or, logical_xor|与或非|

## 利用数组进行数据处理

待细化

## 将条件逻辑表述为数组运算

* np.where(c, x, y)处理多个数组生成新的数组
如果c，则x，否则y。
相当于
```python
[（x if c else y) for c, x, y in (arrc, arrx, arry)]
```

## 数学和统计方法

* np.sum(arr)和np.mean(arr)
  np.sum用于计算和，np.mean()用于计算平均数，也可以调用arr.sum(),arr.mean().
  这两个函数都有一个参数axis，当不输入时，默认将所有数求和或平均数，而当给出参数n时，则将该维的数按序求值，n必须小于最大维度

    ```python
    In [69]: arr
    Out[69]: 
    array([[[1, 2, 3],
            [1, 3, 4]],

           [[3, 4, 1],
            [1, 0, 1]],

           [[1, 3, 4],
            [1, 0, 2]]])

    In [70]: arr.sum(0)
    Out[70]: 
    array([[5, 9, 8],
           [3, 3, 7]])

    In [71]: arr.sum(1)
    Out[71]: 
    array([[2, 5, 7],
           [4, 4, 2],
           [2, 3, 6]])

    In [72]: arr.sum(2)
    Out[72]: 
    array([[6, 8],
           [8, 2],
           [8, 3]])

    ```
* np.cumsum()和np.cumprod()

    ```python
    In [73]: arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

    In [74]: arr.cumsum(0)
    Out[74]: 
    array([[ 0,  1,  2],
           [ 3,  5,  7],
           [ 9, 12, 15]])

    In [75]: arr.cumprod(1)
    Out[75]: 
    array([[  0,   0,   0],
           [  3,  12,  60],
           [  6,  42, 336]])
    ```

#### 基本数组统计方法

|方法|说明|
|:--|:--|
|sum|求和|
|mean|算术平均数|
|std，var|标准差和方差|
|min，max|最大值最小值|
|argmin，argmax|最大最小值的索引|
|cumsum|累积和|
cumprod|累计积|

#### 用于布尔型数组的方法

在基本数组方法中，布尔值会被强制转换成1和0进行计算

另外还有两个方法any和all。any用于测试是否存在True，all检测是否全是True

#### 排序

* sort方法

    sort（n）可对特定轴排序

    ```python
    In [79]: arr
    Out[79]: 
    array([[-0.41090772,  1.27748602,  0.40782367],
           [ 0.27301676, -0.36790053, -0.33207618],
           [-0.06167619,  1.34881466, -2.17207493],
           [ 0.39366453, -0.3848534 ,  0.13948127],
           [-0.43362899,  0.10737108,  1.26094398]])

    In [80]: arr.sort(0)

    In [81]: arr
    Out[81]: 
    array([[-0.43362899, -0.3848534 , -2.17207493],
           [-0.41090772, -0.36790053, -0.33207618],
           [-0.06167619,  0.10737108,  0.13948127],
           [ 0.27301676,  1.27748602,  0.40782367],
           [ 0.39366453,  1.34881466,  1.26094398]])

    In [82]: arr.sort(1)

    In [83]: arr
    Out[83]: 
    array([[-2.17207493, -0.43362899, -0.3848534 ],
           [-0.41090772, -0.36790053, -0.33207618],
           [-0.06167619,  0.10737108,  0.13948127],
           [ 0.27301676,  0.40782367,  1.27748602],
           [ 0.39366453,  1.26094398,  1.34881466]])
    ```
    
#### 唯一化以及其他的集合逻辑

|方法|说明|
|:--|:--|
|unique（x）|计算x中的唯一元素，并返回有序结果（合并相同元素并排序）|
|intersect1d（x，y）|计算x和y中的公共元素，并排序|
|union1d（x，y）|计算x和y的并集，并排序|
|in1d（x，y）|得到一个表示“x的元素是否包含于y”的布尔型数组|
|setdiff1d（x，y）|集合的差，即元素在x中且不在y中|
|setxor1d（x，y）|集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素|

## 用于数组的文件输入输出

#### 将数组以二进制格式保存到磁盘

np.save和np.load用于读写。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中

```python
In [84]: arr = np.arange(10)

In [85]: np.save('some_array', arr)

In [86]: !ls
anaconda3  Documents  Git    Pictures  some_array.npy  Videos
Desktop    Downloads  Music  Public    Templates       Wallpaper

In [87]: np.load('some_array.npy')
Out[87]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

np.savez可将多个数组保存到一个压缩文件中，将数组以关键字参数的形式传入即可

```python
In [90]: np.savez('array_archive.npz', a = arr, b = arr)

In [91]: arch = np.load('array_archive.npz')

In [92]: arch['b']
Out[92]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

#### 存取文本文件

逗号分隔文件

```python
arr = np.loadtxt('array_ex.txt', delimiter = ',')
```

np.savetxt则用于将数组以某种分隔符号隔开写到文本文件中

## 线性代数

#### 常用numpy.linalg函数

|函数|说明|
|:--|:--|
|diag|以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一位数组转换为方阵（非对角线元素为0）|
|dot|矩阵乘法|
|trace|计算对角线元素的和|
|det|计算矩阵行列式|
|eig|计算方阵的本征值和本征向量|
|inv|计算方法的逆|
pinv|计算矩阵Moore-Penrose伪逆|
|qr|计算QR分解|
|svd|计算奇异值分解（SVD）|
|solve|解线性方程Ax = b，其中A为一个方阵
lstsq|计算Ax = b的最小二乘解

## 随机数生成

#### 部分numpy.random函数

|函数|说明|
|:--|:--|
|seed|确定随机数生成器的种子|
|permutation|返回一个序列的随机排列或返回一个随机排列的范围|
|shuffle|对一个序列就地随机排列|
|rand|产生均匀分布的样本值|
|randint|从给定的上下限范围内随机选取整数|
|randn|产生正态分布（平均值为0，标准差为1）的样本值|
|binomial|产生二项分布的样本值|
|normal|产生正态（高斯）分布的样本值|
|beta|产生Beta分布的样本值|
|chisquare|产生卡方分布的样本计算|
|gamma|产生Gamma分布的样本值|
|uniform|产生在[0,1)中均匀分布的样本值|

